1. bug in document(). error returns for VCFArray(seed) after document(): 

-- issue identified as bug in `devtools`: https://github.com/r-lib/devtools/issues/1845
-- workaround now. export `DelayedUnaryOp` and `DelayedOp` classes from `DelayedArray` package (locally modified and installed. install.packages("/home/qian/Documents/Research/DelayedArray", repos=NULL)).

```{r}
seed <- VCFArraySeed(fl, name = "GL")
VCFArray(seed)
## Error in validObject(.Object) : invalid class “DelayedMatrix” object: 
##     'x' must have exactly 2 dimensions
traceback()
## 10: stop(msg, ": ", errors, domain = NA)
## 9: validObject(.Object)
## 8: initialize(value, ...)
## 7: initialize(value, ...)
## 6: new(...)
## 5: new2(Class, seed = seed)
## 4: new_DelayedArray(seed, Class = "VCFArray") at VCFArray-class.R#104
## 3: DelayedArray(seed)
## 2: DelayedArray(seed) at VCFArray-class.R#131
## 1: VCFArray(seed)
```

2. Remove the `Rsamtools` from `DESCRIPTION, Imports` for now. Because the `Rsamtools::countTabix()` function is remove from our script.   -- done!

3. VCFArraySeed(file = "VCFFile")  -- done!
- if (!is.na(index(file)) && length(index)) stop()
- if (is.na(index(file)) && length(index) ) index(file) = index
- if (is.na(index(file)) && !length(index) ) index(file) = paste0(path(file), ".tbi")

4. save header info into `VCFArraySeed`. 
- to extract the header info, geno(header)$Type in `extract_array`.  -- done!
- fail later if `VCFArray(name=NULL)` in `VCFArraySeed(name = )` checking.   -- done!
- extract the possible 3rd dimension of `VCFArraySeed` and save as @dim slot. -- done!
  
5. VCFArraySeed(file = "VCFStack")
- use readVCFStack(param = ) in VCFArraySeed() constructor.   -- done!
- only takes in `RangedVcfStack` object, because it has the rowRanges() available, which is required for the `VCFArraySeed` constructor. -- done!

6. **BUG**: show method for >2 dimensional array.  -- fixed in DelayedArray 0.7.28. 
   bug report: https://github.com/Bioconductor/DelayedArray/issues/25   
```{r}
rgstack
seed <- VCFArraySeed(rgstack, name="SB")
index <- list(1:2, NULL, NULL)
extract_array(seed, index)
index <- list(seq(to=nrow(seed), length.out=2), NULL, NULL)
extract_array(seed, index)
VCFArray(seed)  ## ERROR

### summary: all geno() entries tested and work for rgstack.
### all info() entries tested and work for fl/vcf, except the number>1 entries. 

VCFArray(rgstack, name = "FILTER")
## Error in as.vector(x, mode = "character") : 
##   no method for coercing this S4 class to a vector
VCFArray(rgstack, name = "AC")
## <1000> VCFArray object of type "integer":
## Error in map_x_colnames_to_object_colnames(colnames(object)) : 
##   the DataFrame objects to rbind must have the same number of columns
```

7. type of returned data.    -- done
```
<10376 x 5> VCFMatrix object of type "Float":
```
Could directly extract the "Type" from vcf header. But how to generate the Float(0)/String(0) in R?
different data type within VcfFile and R?? 

**VCF**    **R type**
Integer    integer
Float      numeric
Flag       character
String     character
Character  character

- "Number" special cases: 
A: The field has one value per alternate allele. 
R: The field has one value for each possible allele, including the reference.
G: The field has one value for each possible genotype. 
. (dot): The number of possible values varies, is unknown or unbounded. (list)


8. How about the other data inside VCF? 
- todo: use array(DNAStringSetList/IntegerList/CharacterList) to construct DelayedArray objects. 
- rowData(): REF,ALT, QUAL, FILTER, paramRangeID?
- info(AC, AF, AN, DB, DP, FS, QD, ...)   
- IntegerList? (info: CIEND...)
- DNAStringSet (fixed: REF)

```{r}
fl <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
vcf <- VcfFile(fl)
hdr <- scanVcfHeader(fl)

param <- ScanVcfParam(fixed="ALT", info=NA, geno=NA)
res <- readVcf(vcf, genome="hg19", param=param)
ans <- fixed(res)[["ALT"]]  ## DNAStringSetList -- 

param <- ScanVcfParam(fixed=NA, info="CIEND", geno=NA)
res <- readVcf(vcf, genome="hg19", param=param)
ans <- info(res)[[1]]  ## IntegerList -- DelayedArray( array(IntegerList) )

param <- ScanVcfParam(fixed=NA, info="HOMLEN", geno=NA)
res <- readVcf(vcf, genome="hg19", param=param)
ans <- info(res)[[1]]  ## IntegerList

param <- ScanVcfParam(fixed=NA, info=NA)
res <- readVcfStack(rgstack, param=param)

param0 <- ScanVcfParam(fixed=NA, info=NA, geno=NA)
vcfbasic <- readVcf(vcf, genome="hg19", param=param0)

vcfWhich(param) <- granges(rowRanges(vcfbasic)[c(1:4, 10373:10376)])
res <- readVcf(vcf, genome="hg19", param=param)
## does not return any info() column...
## for "IntegerList" columns of info(vcf), if vcfWhich != NA, will FAIL!

vcfInfo(param) <- "LDAF"
res <- readVcf(vcf, genome="hg19", param=param)

seed <- VCFArraySeed(fl, name="CIEND")
dim(seed)
## [1] 10376
VCFArray(seed)  ## ERROR

seed <- VCFArraySeed(fl, name="CIPOS")
VCFArray(seed)  ## ERROR
```

```{r}
fl <- system.file("extdata", "chr22.vcf.gz",
                  package="VariantAnnotation")
hdr <- scanVcfHeader(fl)
vcfinfo <- as.data.frame(info(hdr)[,1:2])
infos <- rownames(vcfinfo)
param0 <- ScanVcfParam(fixed=NA, info=NA, geno = NA)
vcf0 <- readVcf(fl, genome="hg19", param = param0)
rg <- rowRanges(vcf0)
rgsubset <- rg[c(1:4, seq(to=length(rg), length.out=4))]

## with vcfWhich(), info(CIEND, CIPOS, END, HOMLEN, HOMSEQ, SVLEN, SVTYPE) does not return anything.
param <- ScanVcfParam(fixed=NA, info="CIEND", geno = NA, which = rgsubset)
res <- readVcf(fl, genome="hg19", param = param)
info(res)
DelayedArray(array(info(res)[[1]]))

## without vcfWhich(), info(CIEND, CIPOS, END, HOMLEN, HOMSEQ, SVLEN, SVTYPE) could return results we want. 
param1 <- ScanVcfParam(fixed=NA, info="SVTYPE", geno = NA)
res <- readVcf(fl, genome="hg19", param = param1)
info(res)

## with vcfWhich(), info:ELSE... could return successfully.
param <- ScanVcfParam(fixed=NA, info="LDAF", geno = NA, which = rgsubset)
res <- readVcf(fl, genome="hg19", param = param)
info(res)

```




Martin: 

1. add method of scanVcfHeader::VcfStack, to return the shared header info for all VcfFile objects inside the VcfStack object. 



